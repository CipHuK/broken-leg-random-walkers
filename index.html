<script>
    window.onload = () => {
        const c = document.getElementById("myCanvas");
        const ctx = c.getContext("2d");

        const point = (x, y, weight = 3) => {
            const weightHalf = weight / 2
            ctx.beginPath();
            ctx.arc(x, y, weight, 0, 2 * Math.PI);
            ctx.fill();
        }

        const line = (x, y, dx, dy, weight = 4) => {
            ctx.beginPath();
            ctx.lineWidth = weight;
            ctx.strokeStyle = "green";
            ctx.moveTo(x, y)
            ctx.lineTo(dx, dy)
            ctx.stroke();
        }

        class Walker {
            constructor(x, y) {
                this.x = x
                this.y = y
            }

            next(grid) {
                const chooses = [];

                if (this.x > 0 && grid[this.x - 1][this.y]) {
                    chooses.push(new Walker(this.x - 1, this.y));
                }

                if (this.x < grid.length - 1 && grid[this.x + 1][this.y]) {
                    chooses.push(new Walker(this.x + 1, this.y));
                }

                if (this.y > 0 && grid[this.x][this.y - 1]) {
                    chooses.push(new Walker(this.x, this.y - 1));
                }

                if (grid[0].length - 1 > 0 && grid[this.x][this.y + 1]) {
                    chooses.push(new Walker(this.x, this.y + 1));
                }

                return chooses[Math.floor(Math.random() * chooses.length)]
            }

            display() {

            }
        }

        class Grid {
            constructor(w, h, spacing, offset) {
                this.w = w
                this.h = h
                this.spacing = spacing
                this.offset = offset
                this.grid = []
            }

            initGrid() {
                for (let x = this.offset; x < this.w - this.offset; x += this.spacing) {
                    const row = []
                    for (let y = this.offset; y < this.h - this.offset; y += this.spacing) {
                        row.push(1)
                    }
                    this.grid.push(row)
                }
            }

            display() {
                for (let i = 0; i < this.grid.length; i++) {
                    for (let j = 0; j < this.grid[0].length; j++) {
                        point(i * this.spacing + this.offset, j * this.spacing + this.offset)
                    }
                }
            }
        }

        const spacing = 20
        const offset = spacing

        const display = (grid, walkerList, ctx) => {
            grid.display()

            for (let j = 0; j < 200; j++) {
                for (let i = 0; i < walkerList.length; i++) {
                    if (!walkerList[i]) continue;

                    w = walkerList[i]
                    g.grid[w.x][w.y] = 0

                    const next = w.next(g.grid)

                    if (!next) {
                        // TODO pop from the walker path
                        // TODO tracking of the walker path
                        // Track back until valid path will not be found
                        walkerList[i] = next
                    } else {
                        line(
                            w.x * spacing + offset, w.y * spacing + offset,
                            next.x * spacing + offset, next.y * spacing + offset
                        )

                        walkerList[i] = next
                    }
                }
            }
        }

        const g = new Grid(1000, 500, spacing, offset)
        g.initGrid()
        g.display()


        let ws = [new Walker(0, 0), new Walker(47, 22), new Walker(47, 0), new Walker(0, 22)]

        display(g, ws, ctx)
    }

</script>
<canvas id="myCanvas" width="1000" height="500" style="border:1px solid #000000;">

</canvas>
